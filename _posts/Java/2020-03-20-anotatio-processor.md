---
title: 02:注解处理器&反射
author: Zhusong
layout: post
footer: true
category: Java
date: 2020-3-20
excerpt: "02:注解处理器&反射"
abstract: ""
---

# 概念
* 注解: 是JDK1.5之后加入的功能, 具体参考上一篇[01:注解Annotaion(@interface) & 标记接口](/java-anotation)

> * 源代码时期注解，即注解只出现在 .java 文件中，编译后便不再出现在生成的.class 文件中，这一阶段，对注解的处理有两种方式： 
>  
> 	* 被IDE 中代码检查工具读取，如图 1-1中的 1 处，实时地提示程序员缩写代码中的错误，例如 @Override 注解就是用来检查程序员所复写的父类方法的签名一致性的；
>	* 在原代码编译期间，被程序员在编译器中所注册的注解处理器所读取，如图 1-1中的 2 处，用于生成新的源代码文件参与编译，省去重复地书写样板代码的成本，提升效率，编译之后便被去除，不再出现在 .class 文件中；
* 字节码时期注解，即出现在 .class 文件中的注解，对这类注解的处理主要涉及字节码的修改，需要使用ASM等类库，根据处理时机的不同，也可分为两种方式：
	* 在源代码编译后处理：如果当前工程采用了Gradle、Maven等构建工具来构建，则在源代码被编译为 .class 文件后，可以通过相应地脚本调用使用了ASM库编写的第三方工具来读取文件中的注解并修改 .class 文件中的虚拟机指令，没有采用构建工具，也可以通过命令行来手动更新 .class 文件，虚拟机加载.class 文件时不会加载字节码级注解，如图 1-1中的 3 处所示；
	* 在类加载时处理：通过代理程序，在类加载器加载.class 文件前，读取文件中的注解修改字节码，但并不保存，即原有的.class文件内容不变，内存中处理过的字节码的类被类加载器直接加载到虚拟机中，同样的并不加载.class 文件中的字节码级注解，如图 1-1中的 4 处所示；
* 运行时期注解，即注解被类加载器加载到内存当中，和类的其他构成元素一样被放置于元数据区，供堆区中相应的 class 对象访问，换句话说，此时的注解可以通过反射的方式来读取和处理，这时的处理过程往往是由程序员在编码期间就确定的，是运行效率最低但却是最容易实现的一种注解处理方式，如图 1-1中的 5 处所示；
> 
![1]({{site.assets_path}}/img/java/java_annotation_processor.png){:width="60%"}
>

* 注解处理器: 在定义了注解之后, 如果不去用它, 那它就是毫无意义的, 注解处理器就是用来使用注解的。使用注解的都应该被称作注解处理器。那哪里是作为应用开发程序员可以使用注解的地方呢。其实就是跟三个保留阶段相对应的。
	* 源码级别(SOURCE): 检测是编译器对源码级别的注解使用的, 那我们对源码级别的怎么处理呢, APT(Annotation Processor Tool)就是我们在这个阶段可以使用的。  
	大致步骤: 定义注解 => 创建APT项目处理注解 => 在项目中添加注解  
	这样我们就完成了对源码级别的注解的处理
	
	* 字节码级别(CLASS): 那字节码级别呢, 这里呢, 有高手可以直接去改, 然后再调整MD5码、偏移值之类的, 但是比较费时费力, JDK1.5也提供了Instrument用来修改字节码, 不过也需要对字节码结构有一定的掌握, ASM就是一个帮我们把大部分细节做掉, 只要专注与业务就行的方式。在什么时候进行修改呢, 看一下Android打包过程
> 
![1]({{site.assets_path}}/img/android/android-aapt.png){:width="60%"}
>	
	
		在.class与.dex之间, 会有transform的过程, 我们可以通过Android Studio提供的Tranform来实现字节码的修改, 由于要使用ASM代码, 如果直接在build.gradle文件里写会比较麻烦,可以自定义Gradle的插件, 在插件中实现修改, 在项目中应用这个插件即可, 效果如下
> 
![1]({{site.assets_path}}/img/android/android-grale-plugin.png){:width="60%"}
>	
	* 运行时级别(RUNTIME): 前面的注解处理器, 其实都是修改源文件, 在运行时几乎没什么性能影响, 但是运行时的话, 也可以识别注解并处理
		*  自己实现工具类, 在需要的时刻, 去反射获取方法, 参数等, 根据注解执行任务
		*  另外一种其实原理类似的方式, 只不过是使用系统提供的Proxy(动态代理), 每次执行方法都会调用invoke, 获取注解进行调整, 但是这种局限性比较多, 是代理接口。
	这两种方法都是以反射作为基础, 效率比较低, 参考《AOP 的利器：ASM 3.0 介绍》就是, 效率相差有10倍。

# 参考链接
  
注解和注解处理器    
<https://www.jianshu.com/p/acbb293722bc>

AOP 的利器：ASM 3.0 介绍  
<https://www.ibm.com/developerworks/cn/java/j-lo-asm30/index.html>

Android Transform + ASM 初探  
<https://juejin.im/post/5cc3db486fb9a03202222154>