---
title: 00:Java内存模型(JMM) & JVM内存结构 & Java对象模型
author: Zhusong
layout: post
footer: true
category: Java
date: 2020-3-19
excerpt: "00:Java内存模型(JMM) & JVM内存结构 & Java对象模型"
abstract: ""
---

# 零: 概念

* Java内存模型(JMM): 跟Java的 __并发编程__ 有关
* JVM内存结构: 跟Java虚拟机 __运行时区域__ 有关
* Java对象模型: 跟Java对象在虚拟机中 __表现形式__ 有关

# 一: Java内存模型
Java虚拟机规范中试图定义一种Java内存模型(Java Memory Model, JMM)来屏蔽各种硬件和操作系统的内存访问差异, 以实现让Java程序在各种平台下都能达到一致的内存访问效果。

Java内存模式是对硬件内存模型的一种抽象, 所以有很多相似之处, 所以先了解下硬件内存模型的实现。由于CPU处于高速发展的过程, 并且Amdahl定律替换摩尔定律(简单来说就是并行化替换了串行化)来尽量压榨计算机的计算能力, 但是内存的发展较为缓慢, 导致内存的读写跟不上CPU的处理速度, 为了解决这个问题, 在CPU与内存之间引入了高速缓存的概念, 这样就解决了CPU处理与读写的问题。

但是这个还存在另外一个问题, 就是缓存与主内存的一致性, 就引入了“缓存一致性”协议。同时为了尽量利用CPU的计算能力, 处理器就对代码进行乱序执行(Out-Of-Order Execution)优化, 把没有依赖关系的代码进行重组,  但是保证最终的结果与顺序执行的结果在 __单线程情况下__ 一致。

## 硬件内存模型

![1]({{site.assets_path}}/img/java/java_cpu_cache_device.png){:width="60%"}

## Java内存模型

![2]({{site.assets_path}}/img/java/java_jmm.png){:width="60%"}

## 对比
虽然两者看着差不多, 但是Java内存模式对应的工作内存与主内存并没有指明硬件对应的内存位置, 两者没有关系, 只要硬件实现符合Java内存模型的规范即可。

## 重排序
在执行程序时, __为了提高性能，编译器和处理器常常会对指令进行重排序。__ 一般重排序可以分为如下三种：(1)属于编译器重排序，而(2)和(3)统称为处理器重排序。  

这些重排序会导致线程安全的问题，一个很经典的例子就是DCL问题。JMM的编译器重排序规则会禁止一些特定类型的编译器重排序；针对处理器重排序，编译器在生成指令序列的时候会通过插入 __内存屏障指令__ 来禁止某些特殊的处理器重排序。

（1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；  
（2）指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；  
（3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。  

## 内存间的原子操作

* lock 作用与主内存中的变量,把一个变量标志为 __线程独占__ 的(monitorenter)
* unlock 作用与主内存中的变量,把一个变量从锁定中 __释放__ 出来(monitorexit)
* read 作用与主内存中的变量, 把主内存中的变量的 __值__ 读取到工作内存中, 用于之后的load更新到工作内存的 __副本变量__ 中
* load 作用与工作内存的变量, 把read读取的主内存的变量的 __值__ 加载到工作内存的 __副本变量__ 中
* store 作用与工作内存的变量, 把工作内存的副本变量的 __值__ 保存到主内存中, 用于之后更新主内存的 __变量__ 中
* write 作用与主内存中的变量, 把store操作从工作内存中得到的 __值__ 更新到主内存的 __变量__ 中
* use 作用与工作内存中的变量, 把工作内存中的变量的 __值__ 传递给 __执行引擎__, 当虚拟机遇到一个需要使用变量的 __值__ 的字节码指令时将会执行这个操作
* assign 作用与工作内存中的变量, 它把一个从 __执行引擎__ 收到的 __值__ 赋给工作内存的 __变量__, 每当虚拟机遇到一个给 __变量赋值__ 的字节码指令时将会执行这个操作


## 先行发生原则

用来确定一个访问在并发情况下是否安全。

1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。

2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。

### 具体规则
* 程序次序规则: 在单线程内, 书写在前面的操作会先行发生于后面的操作
* 监视器锁定规则: 一个解锁unlock操作一定发生与一个锁定lock操作
* volatile规则: 对一个volatile的写操作一定发生与之后发生的读操作(保证了可见性, 读取肯定是最新值)
* 传递性: A操作先行发生于B, B操作先行发生于C, 那A操作一定先行发生于C
* 线程中断规则: 调用interrupt()先行发生于对线程中断的检测isInterrupted()。  
	
	> 由于interrupt方法调用更新了一个volatile修饰的Interruptible对象, 用于更新中断标志位。
	
* 线程启动规则: start方法先行发生于该线程内的所有动作。
* 线程终止规则: 在线程A中, 线程B在调用join方法后, 线程A会等到线程B执行结束, 才会继续执行, 即线程B先行发生于线程B在调用join之后的操作。
	
	> join无参方法就是检测isAlive方法, 如果存活就wait(0)一直等待, 知道线程结束调用notifyAll释放当前线程对象的锁(因为join方法是synchronized修饰的方法, 所以它的锁就是线程对象)
	
* 对象终结规则: 一个对象的初始化(\<init\>)完成, 先行发生于它的finalize方法。


## 内存屏障

按照内存屏障所起的作用来划分，将内存屏障划分为以下几种。

按照可见性保障来划分。内存屏障可分为 __加载屏障（Load Barrier）__ 和 __存储屏障（Store Barrier）__ 。

* 加载屏障的作用是 __刷新处理器缓存(就是读取主内存中变量的值 更新 到工作内存的副本变量的值)__ ，存储屏障的作用 __冲刷处理器缓存(就是把工作内存的副本变量的值 更新到 主内存中变量的值)__ 。

* Java虚拟机会在 __monitorexit(释放锁)__  对应的机器码指令之后插入一个 __存储屏障(store&write)__ ，这就保障了写线程在释放锁之前在临界区中对共享变量所做的更新对读线程的执行处理器来说是可同步的。相应地，Java 虚拟机会在 __monitorenter(申请锁)__ 对应的机器码指令之后临界区开始之前的地方插入一个 __加载屏障(read&load)__ ，这使得读线程的执行处理器能够将写线程对相应共享变量所做的更新从其他处理器同步到该处理器的高速缓存中。因此，可见性的保障是通过写线程和读线程成对地使用存储屏障和加载屏障实现的。

## 原子性、可见性、有序性

### 原子性
由Java内存模型保证的原子性操作有8个, lock, unlock, read, load, store, write, use, assign。
可以认为基本类型的读写是具备原子性的。

> Java内存模型中定义了一条相对宽松的规则, 允许没有volatile修饰的64位数据读写分为2次32位的操作(猜测是为了32位系统考虑的)。但是它 __强烈建议__ 把它处理成具有原子性的操作, 在商用Java虚拟机都是这么做的。
> 
> 那如果就是没这么做怎么处理呢
> 1. 使用volatile修饰  
> 2. 读写都用synchronized代码块包裹  
> 3. 使用ReentrantLock的lock, unlock包裹, try-finally

为了保证更大范围的原子性保证, Java内存模型提供的lock & unlock 来保证, 对应的字节码指定就是monitorenter & monitorexit来隐式的调用这2个原子操作, 对应到上层代码的关键字就是synchronized 和 ReentrantLoack类。

### 可见性

可见性是指当一个线程修改了共享变量的值, 其他线程能立即得到这个修改。Java内存模型是通过在变量修改后将新值同步回主内存中, 在变量读取前从主内存中更新变量值这种, 依赖主内存作为传递媒介实现可见性的。

TODO











## ReentrantLock & synchronized

## synchronized

JDK[0, 1.6)是一个重量级锁, JDK[1.6, -]优化了synchronized, 通过一个锁升级的过程, 优化锁的过程。


无锁 => 偏向锁 => 轻量级锁 => (自旋锁) => 重量级锁

### Java对象布局

| Java对象布局||
|:---:|:---:|
| Mark Word|
| Kclass|
|实例数据|
|对齐数据| 8位对齐, 不满用0补齐, 刚好8位就没有这部分|




### Mark Word

在Java对象布局中, MarkWord(对应C++结构markOop)   
末尾2bit来记录对象锁类型, 如果是可偏向锁, 往前1bit来记录是否是偏向锁(0无锁 1偏向锁)  
另外还包含哈希码(HashCode), GC分代年龄(Generational GC Age)  
这个字段是实现轻量锁和偏向锁的关键

||1bit| 2bit|锁状态|
|:---:|:---:|:---:|:---:|
|存储内容|偏向锁|锁标志位|
|对象哈希码, 对象分代年龄|0| 01|无锁|
|偏向线程ID, 偏向时间戳, 对象分代年龄|1| 01|偏向锁|
|指向锁记录的指针|| 00|轻量级锁|
|指向重量级锁的指针|| 10|重量级锁|
|空|| 11|GC标志|

### LockRecord

OpenJDK中LockRecord对象

```c++
// A BasicObjectLock associates a specific Java object with a BasicLock.
// It is currently embedded in an interpreter frame.
class BasicObjectLock VALUE_OBJ_CLASS_SPEC {
 private:
  BasicLock _lock;                        // the lock, must be double word aligned
  oop       _obj;                         // object holds the lock;
};
class BasicLock VALUE_OBJ_CLASS_SPEC {
 private:
  volatile markOop _displaced_header;
};
```
锁记录(LockRecord) 在对象没有被锁定(锁标志位01)时创建。  
备份锁对象目前的Mark Word, 记录在\_displaced_header中, 称作Displaced Mark Word。  
更新这个锁记录的对象, 记录在\_obj中。  


### 锁过程

#### 偏向锁  

加锁

* 第一次被线程获取时, 更新Mark Word的锁标志位为01, 可偏向模式
* 检测偏向锁标志位是可偏向状态(是01),
	* 如果偏向锁标志位是(0), 就更新为1, 并更新ThreadID为当前线程ID(CAS), 进入同步代码块
	* 如果偏向锁标志位是(1), 就对比当前线程跟记录的ThreadID是否相同
		* 相同线程ID, 直接进入同步代码块
		* 不同线程ID, 撤销偏向锁, 升级锁
* 检测偏向锁标志位不是可偏向状态(不是01)
	* 升级轻量锁锁定

撤销

* 如果偏向锁是当前线程
	* 如果线程不存活/不在同步代码块, 就撤销偏向锁, 偏向锁标志位(0)
	* 否则遍历线程所有的LockRecord 
		* 没有找到当前锁对象的线程, 撤销偏向锁
		* 找到了当前锁对象的线程, 根据顺序获取到最高优先级的锁highest_lock, 并取消它的偏向锁, 再把对象的Mark Word指向这个新的LockRecord, 完成锁的升级
* 如果不是当前线程, 会把撤销操作push到VM Thread, 等到全局安全点进行撤销 


适用于同一个线程反复进入同步代码块, 结束偏向锁同步代码块什么都不需要干, 只有升级的时候需要撤销。
如果很多线程来竞争锁, 偏向锁就是无用, 而且还会有性能消耗, 需要反复的加锁撤销锁, 比如使用线程池来执行任务, 如果不同的任务使用同一个对象作为锁, 那就会反复的加锁撤销, 偏向锁就没有了意义。

原理

当线程第一次获取锁时, 虚拟机会把对象头中的标志位设置为01, 即偏向模式, 同时使用CAS(Compare And Swap)操作把当前线程的ID值更新到对象同的线程ID中, 如果CAS成功, 持有偏向锁的线程, 每次进入这个锁相关的同步代码块时, 虚拟机不需要做任何工作, 效率非常高。

答疑

Q: 如果同一个线程反复获取同步代码块, 直接不加synchronized不是一样么?  
A: 如果这个线程的工作是独立的, 没有任何其他数据共享的, 确实不需要加, 但是更多时候还是需要用到一些共享的变量。那就需要同步的方式尽快同步到主内存或者每次从主内存刷新读取。

#### 轻量级锁
轻量级是相对于monitor的传统锁而言的。他并不是代替重量级锁的, 只是在多线程 __交替__ 执行同步代码块, 避免重量级锁的性能消耗, 但是多个线程 __同时__ 进入临界区, 会导致轻量级锁膨胀升级成重量级锁, 所以轻量级锁只是在减轻进入重量级锁的性能消耗, 并不是替换, 可以理解成前置优化。


升级过程:  

* 当有另一个线程去尝试获取锁, 如果已经被锁定结束偏向模式
* 根据锁对象当前是否被锁定的状态
	* 如果未被锁定, 就撤销偏向锁, 更新为轻量锁
		* 构建一个无锁的Displaced Mark Word(就是把锁对象的Mark Word的锁标志位更新成00)
		* 通过CAS操作尝试将锁对象的Mark Word,更新为指向Lock Record的指针。
			* 更新成功表示升级轻量锁成功
			* 更新失败先判断是否为重入
				* 如果为重入, 就清除这次重入的LockRecord的Displaced Mark Word, 通过LockRecord作为重入的次数
				* 不为重入, 表示多个线程 __同时__ 竞争同一把锁, 升级成重量级锁
	* 如果锁已经被锁定, 更新锁


更新成功之后, 表示该线程拥有了该对象的锁, 

如果此对象没有被锁定(锁标志位01), 虚拟机首先在当前线程的栈帧里创建一个锁记录(LockRecord)  
备份锁对象目前的Mark Word, 记录在\_displaced_header中。
	
	


1.7 之后尽量不调用

# 参考

happen-before原则  
<https://blog.csdn.net/ma_chen_qq/article/details/82990603>

synchronized 实现原理与内存屏障   
<https://www.jianshu.com/p/39ecb11d41d7>

死磕Synchronized底层实现  
<https://www.jianshu.com/p/4758852cbff4>