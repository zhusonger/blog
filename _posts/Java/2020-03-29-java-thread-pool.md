---
title: 06:Java线程以及线程池
author: Zhusong
layout: post
footer: true
category: Java
date: 2020-3-29
excerpt: "06:Java线程以及线程池"
abstract: ""
---

# 概念
线程是CPU调度的最小单位。  
线程的实现主要有3种实现方式。 

* 内核线程(Kernel-Level Thread, KLT)

	> 内核线程就是内核通过调度器(Scheduler)对线程进行调度, 并负责将线程的任务映射到各个处理器(CPU)上。不过程序一般不会直接去使用内核线程, 而是去使用内核线程的一种高级接口, 轻量级进程(Light Weight Process, LWP)。基于内核线程实现的, 所以需要在用户态与内核太切换, 消耗会比较大。但是各自独立, 一个线程阻塞不会影响整个进程工作。
	
* 用户线程(User-Level Thread, ULT)

	> 只要不是内核线程, 就可以认为是用户线程。从这个定义来说, 轻量级进程(LWP)也属于用户线程。狭义来说, 是完全建立在用户空间的线程库,内核线程不能感知到线程的存在, 不需要内核的帮助。  
	> 如果实现足够完善, 那理论上来说, ULT是一种很好的实现, 可以非常高效的运行。跟之前的ReentrantLock一样, 在最后才会进入系统刮起, 调用到内核资源。可以支持更大的线程数量。  
	> 但是现实是线程的创建, 调度, 阻塞, 映射到处理器实现起来都异常困难。所以现在的实现基本都不完全使用用户线程了。

* 结合上面2种线程实现, 用户线程与内核线程混合实现

	> 混合模式的情况下, 轻量级进程(LWP)作为用户进程与内核线程的桥梁。

# Java线程的实现
由于线程的实现很大程序取决于系统的线程模型来实现。目前来说, Java在Windows与Linux线程都是1:1的线程模型, 即1个Java线程对应到一个轻量级进程(LWP)。
	
# 线程调用的方式

## 协同式线程调度
线程的执行时间由线程自己控制, 线程把工作做完之后, 主动通知系统切换到另外一个线程中。

* 优点: 线程完全由自己控制, 切换操作都是自己控制, 所以没有线程同步的问题。
* 缺点: 线程执行时间不可控, 如果代码实现有问题, 没有主动通知系统切换线程, 一直占用系统的资源。这样的实现方式全依赖应用程序的稳定性, 如果实现不好, 会把整个系统搞崩。
	
## 抢占式线程调度
每个线程的执行时间由系统来分配, 线程的切换不由线程控制。Java的yield可以让出执行时间, 但是什么时候执行还是不可知的。所以会存在同步问题。
优点: 系统稳定, 不会出现某个线程一直占用资源, 如果某个进程出了问题, 就可以通过杀死这个进程。

## Java的调用方式
说完2者的区别, 肯定也能得出结论, Java就是使用抢占式的线程调度。不过线程实现了一个优先级, 建议系统根据优先级多分配一些运行时间。不过这个映射关系跟系统线程模型的优先级有关, 可能会出现多个Java线程优先级在系统的优先级是一样的。

# 状态
* 新建(New)

	> 创建后未开启状态
	
* 运行(Runnable)

	> 包括Ready以及Running, 正在运行或者等待CPU分配执行时间。
	
* 无限期等待(Waiting)

	> 无限期等待, 不会被分配CPU执行时间, 直到其他线程显示的唤醒它们。
	>
	> * Object.wait()方法
	> * Thread.join()方法 => 内部还是wait
	> * LockSupport.park()方法 => 底层互斥量实现阻塞
		
* 限期等待(Timed Waiting)

	> 有超时时间的等待, 不会被分配CPU执行时间, 时间到了之后自动唤醒。
	>
	> * Thread.sleep(timeout)方法
	> * Object.wait(timeout)方法
	> * Thread.join(timeout)方法
	> * LockSupport.parkNanos(timeout)方法
	> * LockSupport.parkUtil(timestamp)方法
	
* 阻塞(Blocked)

	> 线程被阻塞, 跟等待的区别是, 阻塞是进入同步块时的状态, 在等待获取到一个排他锁的时候。获取到锁就进入Runnable, 否则就阻塞, 这是我们同步线程中经常碰到的情况。涉及到锁升级也是在这里。  
	> synchronized
	
* 结束(Terminated)

	> 线程已终止, 结束执行。


# 线程池
从上面线程的实现方式可以看到, 如果没有节制的创建线程, 对系统来说是一个很消耗性能的工作, 那我们创建线程池, 就是相当于固定了线程的个数, 避免线程的无限创建。没有工作的时候核心线程就等待/阻塞, 有任务就使用线程池里的线程执行任务, 这样就限制了线程数量。

# 线程池的优势
* 控制线程数量, 减少系统压力
* 减少线程创建与销毁的资源消耗
* 任务与线程分离, 提升线程复用

# 线程数实现

	