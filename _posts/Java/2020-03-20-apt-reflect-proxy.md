---
title: 02:注解处理器&反射&动态代理
author: Zhusong
layout: post
footer: true
category: Java
date: 2020-3-20
excerpt: "02:注解处理器&反射&动态代理"
abstract: ""
---

# 概念
* 注解: 是JDK1.5之后加入的功能, 具体参考上一篇[01:注解Annotaion(@interface) & 标记接口](/java-anotation)

> * 源代码时期注解，即注解只出现在 .java 文件中，编译后便不再出现在生成的.class 文件中，这一阶段，对注解的处理有两种方式： 
>  
> 	* 被IDE 中代码检查工具读取，如图 1-1中的 1 处，实时地提示程序员缩写代码中的错误，例如 @Override 注解就是用来检查程序员所复写的父类方法的签名一致性的；
>	* 在原代码编译期间，被程序员在编译器中所注册的注解处理器所读取，如图 1-1中的 2 处，用于生成新的源代码文件参与编译，省去重复地书写样板代码的成本，提升效率，编译之后便被去除，不再出现在 .class 文件中；
* 字节码时期注解，即出现在 .class 文件中的注解，对这类注解的处理主要涉及字节码的修改，需要使用ASM等类库，根据处理时机的不同，也可分为两种方式：
	* 在源代码编译后处理：如果当前工程采用了Gradle、Maven等构建工具来构建，则在源代码被编译为 .class 文件后，可以通过相应地脚本调用使用了ASM库编写的第三方工具来读取文件中的注解并修改 .class 文件中的虚拟机指令，没有采用构建工具，也可以通过命令行来手动更新 .class 文件，虚拟机加载.class 文件时不会加载字节码级注解，如图 1-1中的 3 处所示；
	* 在类加载时处理：通过代理程序，在类加载器加载.class 文件前，读取文件中的注解修改字节码，但并不保存，即原有的.class文件内容不变，内存中处理过的字节码的类被类加载器直接加载到虚拟机中，同样的并不加载.class 文件中的字节码级注解，如图 1-1中的 4 处所示；
* 运行时期注解，即注解被类加载器加载到内存当中，和类的其他构成元素一样被放置于元数据区，供堆区中相应的 class 对象访问，换句话说，此时的注解可以通过反射的方式来读取和处理，这时的处理过程往往是由程序员在编码期间就确定的，是运行效率最低但却是最容易实现的一种注解处理方式，如图 1-1中的 5 处所示；
> 
![1]({{site.assets_path}}/img/java/java_annotation_processor.png){:width="60%"}
>

# 注解处理器
在定义了注解之后, 如果不去用它, 那它就是毫无意义的, 注解处理器就是用来使用注解的。使用注解的都应该被称作注解处理器。那哪里是作为应用开发程序员可以使用注解的地方呢。其实就是跟三个保留阶段相对应的。
	
* 源码级别(SOURCE)  
检测是编译器对源码级别的注解使用的, 那我们对源码级别的怎么处理呢, APT(Annotation Processor Tool)就是我们在这个阶段可以使用的。  使用到的类就是AbstractProcessor。  
	大致步骤: 定义注解 => 创建APT项目处理注解 => 在项目中添加注解    
	这样我们就完成了对源码级别的注解的处理
	
* 字节码级别(CLASS)  
那字节码级别呢, 这里呢, 有高手可以直接去改, 然后再调整MD5码、偏移值之类的, 但是比较费时费力, JDK1.5也提供了Instrument用来修改字节码, 不过也需要对字节码结构有一定的掌握, ASM就是一个帮我们把大部分细节做掉, 只要专注与业务就行的方式。
		
	* ASM   
	首先我们先来看下Android打包过程  
	
		> 
		![1]({{site.assets_path}}/img/android/android-aapt.png){:width="60%"}
		>	

		在.class与.dex之间, 会有transform的过程, 我们可以通过Android Studio提供的Tranform来实现字节码的修改, 由于要使用ASM代码, 如果直接在build.gradle文件里写会比较麻烦,可以自定义Gradle的插件, 在插件中实现修改, 在项目中应用这个插件即可, 效果如下
	> 
	![1]({{site.assets_path}}/img/android/android-grale-plugin.png){:width="60%"}
	>	
	* 自定义类加载器   
		类加载器负责读取字节码文件(.class)到内存中, 并转换成java.lang.Class实例对象来表示一个类, 这里在读取字节码文件, 转换成Class对象的时候, 我们也可以根据注解来修改字节码, 除了处理注解, 也可以做热部署等其他功能, 所以再写一篇文章针对类加载器的。
			
* 运行时级别(RUNTIME)  
前面的注解处理器, 其实都是修改源文件, 在运行时几乎没什么性能影响, 但是运行时的话, 也可以识别注解并处理。
		*  自己实现工具类, 在需要的时刻, 去反射获取方法, 参数等, 根据注解执行指定的功能。

# 反射
反射这东西看着很神神叨叨, 其实说白了跟平时我们取一个对象, 调用它的方法一样。区别只是我们取的是java.lang.Class这个代表类结构的对象而已, Class对象它可以是在堆中, 也可以是在方法区中, Java虚拟机规范并没有明确规定, 但是作为代表类的对象, 一般来说, 会放到GC光顾比较少的方法区, 这个是具体的虚拟机的实现, 看虚拟机设计者的考量。

> 自定义类加载器的加载的类则一般会放到堆中, 因为正常被虚拟机创建的系统类加载器加载的类, 跟虚拟机创建的系统类加载器生命周期是一致的, 所以跟虚拟机的生命周期也一致(一直持有虚拟机创建的类加载器的引用, 系统类加载器属于GCRoots, 根据可达性分析, 这个系统类加载器加载的类只要虚拟机不死, 它就存活)  
> 
> 而自定义类加载器加载的类是持有自定义加载器, 自定义加载器可能是方法里临时创建的(即栈帧里的局部变量表的变量), 会随着方法结束(栈帧出栈)而回收, 那自定义类加载器加载的类, 它引用的自定义类加载器已经回收了, 它自然也被回收了, 如果想要存在, 就要让自定义类加载器不被回收, 比如static修饰成类变量。 这就是类的卸载与回收。
> 
> 这个自定义类加载器加载动态生成的类(class)就是下一节动态代理的部分, 很多Web的框架都使用动态代理玩出很多花样, 不过还是要考虑到类的卸载与回收的。如果没有节制的创建新的类, 加载到内存中, 如果虚拟机的设计是放到方法区的, 而方法去的内存并不大, 比如几百兆, 那在一个长时间运行的服务器上, 还是会出现PerGem heap outmemory, 即方法区内存溢出。
> 

上面的是题外话了, 回到反射。反射就是去取Class对象的各种属性, Class对象是虚拟机根据字节码文件(.class)得到的一个代表它的一个对象。反射就是取它的Field, Method等根据字节码文件解析出来的属性而已。
		
# 动态代理
动态代理的“动态”是相对于平时编写的源码而言的, 它的动态还是依赖与程序员来实现的。动态代理使用的场景是运行时(Runtime), 其根本方式就是实现系统类加载器加载我们的编写的代码转换的字节码一样。  

* 过程如下  
生成字节码二进制流 => 使用类加载器加载到方法区 => 通过反射的方式去获取它的属性 => 再然后就是跟我们平时熟悉的调用反射的方式一样

## 动态代理的实现方式

* Proxy
	这个是JDK提供的一个字节码生成的工具类。位于java.lang.reflect包下, 平时我们偶尔会用到的方法 Proxy.newProxy就是这个, 只是它是一层更上层的封装, 做了一些优化处理, 最后生成.class字节码文件是通过 ProxyGenerator.generateProxyClass, 你要是对字节码文件熟悉, 你完全可以自己实现一个类去生成字节码。 只要根据Java虚拟机给的规范来即可。  
	Proxy的生成方式有一点限制, 那就是只能去实现接口。
	
	```
	byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
                proxyName, interfaces, accessFlags);
	```
	
* CGLib & ASM  
	CGLib是对系统提供的Proxy只能针对接口实现动态代理不太满意。然后扩展了下, 通过继承原有类来实现动态代理, 说白了就是我把你字节码文件复制过来, 我改一改, 改成继承你, 然后再修改Class文件格式里的方法啊, 字段啊, 改完之后使用自定义类加载器 或者 获取类加载器加载来加载这个新的类,然后使用。  
	由于是按照规范来的。那就必须按照Java语法规定的不能对父类的一些内容去修改, 比如不能重写final方法, 不能缩小父类修饰符范围, 比如父类方法是public, 你给改成protected。  
	底层字节码修改还是通过上面注解处理器里说的ASM来实现的。
> 这里需要继承父类的考虑是, 对类进行增强。如果不需要父类, 你都不需要用到这个框架。比如你想加载一个下载下来的类, 直接读取二进制流, 然后让类加载器加载就行了。


# 参考链接
  
注解和注解处理器    
<https://www.jianshu.com/p/acbb293722bc>

AOP 的利器：ASM 3.0 介绍  
<https://www.ibm.com/developerworks/cn/java/j-lo-asm30/index.html>

Android Transform + ASM 初探  
<https://juejin.im/post/5cc3db486fb9a03202222154>

CGLib  
<https://github.com/cglib/cglib/wiki/How-To>